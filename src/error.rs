use std::ffi::CStr;
use std::fmt::{self, Display};

use crate::raw::*;

/// Diagnostic info provided by spirv-tools 
#[derive(Clone, Debug)]
pub struct DiagnosticInfo {
    diagnostic: String
}

impl DiagnosticInfo {
    /// Create a new diagnostic info from the provided diagnostic object 
    /// 
    /// # Safety
    /// Assumes that the diagnostic pointer is valid or null
    pub(crate) unsafe fn from_raw(diag: spv_diagnostic) -> Option<DiagnosticInfo> {
        if diag.is_null() {
            return None;
        }

        let mut diag_str = String::with_capacity(64);
        diag_str.push_str("Error: ");

        // Error is a textual error
        if (*diag).is_text_source {
            let line   = (*diag).position.line;
            let column = (*diag).position.column;
            let error  = CStr::from_ptr((*diag).error)
                .to_str()
                .unwrap_or("Invalid error string");

            let out_str = format!("{}: {}: {}", line, column, error);

            diag_str.push_str(&out_str);
        }
        // Error is a binary error
        else {
            let index = (*diag).position.index;
            let error = CStr::from_ptr((*diag).error)
                .to_str()
                .unwrap_or("Invalid error string");

            let out_str = format!("{}: {}", index, error);

            diag_str.push_str(&out_str);
        }

        Some(Self { diagnostic: diag_str })
    }

    /// Convert the diagnostic info into a string
    pub fn to_string(self) -> String {
        self.diagnostic
    }
}

impl Display for DiagnosticInfo {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.diagnostic)
    }
}

/// An error raised during assembly
#[derive(Clone, Debug)]
pub enum AssembleError<'src> {
    /// An invalid source string was provided
    /// 
    /// (under)
    InvalidSourceString(&'src str),

    /// An error that originated from spirv tools
    SpirvTools(SpvError, Option<DiagnosticInfo>)
}

/// An error raised during disassembly
#[derive(Clone, Debug)]
pub enum DisassembleError {
    /// An error that originated from spirv tools
    SpirvTools(SpvError, Option<DiagnosticInfo>)
}

/// An error raised during validation
#[derive(Clone, Debug)]
pub enum ValidateError {
    /// An error that originated from spirv tools
    SpirvTools(SpvError, Option<DiagnosticInfo>)
}

/// An error raised during optimization
#[derive(Clone, Debug)]
pub enum OptimizerError<'flag> {
    /// An invalid flag was provided.
    /// 
    /// (provided flag)
    InvalidFlag(&'flag str),

    /// Optimization failed for some reason
    OptimizationFailed()
}

/// An error generated by spirv-tools
#[derive(Clone, Debug)]
pub enum SpvError {
    Unsupported,
    EndOfStream,
    Warning,
    FailedMatch,
    RequestedTermination,
    Internal,
    OutOfMemory,
    InvalidPointer,
    InvalidBinary,
    InvalidText,
    InvalidTable,
    InvalidValue,
    InvalidDiagnostic,
    InvalidLookup,
    InvalidId,
    InvalidCfg,
    InvalidLayout,
    InvalidCapability,
    InvalidData,
    MissingExtension,
    WrongVersion,
}

impl SpvError {
    /// Create an error from it's raw representation.
    /// 
    /// # Safety
    /// Assumes that `spv_dignostic` is either null or a valid pointer
    /// 
    /// # Panics
    /// Panics if the result is not an error
    pub(crate) unsafe fn from_raw(result: spv_result_t, diag: spv_diagnostic) -> (Self, Option<DiagnosticInfo>) {
        assert!(result != spv_result_t::SUCCESS);

        (
            SpvError::from_result(result),
            DiagnosticInfo::from_raw(diag)
        )
    }

    /// Convert an `spv_result_t` into an `SpvError`
    fn from_result(result: spv_result_t) -> Self {
        match result {
            spv_result_t::UNSUPPORTED               => SpvError::Unsupported,
            spv_result_t::END_OF_STREAM             => SpvError::EndOfStream,
            spv_result_t::WARNING                   => SpvError::Warning,
            spv_result_t::FAILED_MATCH              => SpvError::FailedMatch,
            spv_result_t::REQUESTED_TERMINATION     => SpvError::RequestedTermination,
            spv_result_t::ERROR_INTERNAL            => SpvError::Internal,
            spv_result_t::ERROR_OUT_OF_MEMORY       => SpvError::OutOfMemory,
            spv_result_t::ERROR_INVALID_POINTER     => SpvError::InvalidPointer,
            spv_result_t::ERROR_INVALID_BINARY      => SpvError::InvalidBinary,
            spv_result_t::ERROR_INVALID_TEXT        => SpvError::InvalidText,
            spv_result_t::ERROR_INVALID_TABLE       => SpvError::InvalidTable,
            spv_result_t::ERROR_INVALID_VALUE       => SpvError::InvalidValue,
            spv_result_t::ERROR_INVALID_DIAGNOSTIC  => SpvError::InvalidDiagnostic,
            spv_result_t::ERROR_INVALID_LOOKUP      => SpvError::InvalidLookup,
            spv_result_t::ERROR_INVALID_ID          => SpvError::InvalidId,
            spv_result_t::ERROR_INVALID_CFG         => SpvError::InvalidCfg,
            spv_result_t::ERROR_INVALID_LAYOUT      => SpvError::InvalidLayout,
            spv_result_t::ERROR_INVALID_CAPABILITY  => SpvError::InvalidCapability,
            spv_result_t::ERROR_INVALID_DATA        => SpvError::InvalidData,
            spv_result_t::ERROR_MISSING_EXTENSION   => SpvError::MissingExtension,
            spv_result_t::ERROR_WRONG_VERSION       => SpvError::WrongVersion,

            _                                       => panic!("Not an error!")
        }
    }
}