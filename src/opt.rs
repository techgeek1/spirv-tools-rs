use std::ffi::CString;
use std::ptr;

use crate::{TargetEnv, ValidatorOptions};
use crate::error::*;
use crate::raw::*;

/// A set of options for configuring an optimizer pass 
pub struct OptimizerOptions {
    raw: spv_optimizer_options
}

impl OptimizerOptions {
    /// Create a new optimizer options
    pub fn new() -> Self {
        Self {
            raw: unsafe { spvOptimizerOptionsCreate() }
        }
    }
    
    /// Records whether or not the optimizer should run the validator before
    /// optimizing.  If |val| is true, the validator will be run.
    pub fn run_validator(self, value: bool) -> Self {
        unsafe { spvOptimizerOptionsSetRunValidator(self.raw, value); }
        self
    } 

    /// Records the validator options that should be passed to the validator if it is
    /// run.
    pub fn validator_options(self, options: ValidatorOptions) -> Self {
        unsafe { spvOptimizerOptionsSetValidatorOptions(self.raw, options.raw); }
        self
    }

    /// Records the maximum possible value for the id bound.
    pub fn max_id_bound(self, value: u32) -> Self {
        unsafe { spvOptimizerOptionsSetMaxIdBound(self.raw, value); }
        self
    }

    /// Records whether all bindings within the module should be preserved.
    pub fn preserve_bindings(self, value: bool) -> Self {
        unsafe { spvOptimizerOptionsSetPreserveBindings(self.raw, value); }
        self
    }

    /// Records whether all specialization constants within the module
    /// should be preserved.
    pub fn preserve_spec_constants(self, value: bool) -> Self {
        unsafe { spvOptimizerOptionsSetPreserveSpecConstants(self.raw, value); }
        self
    }

    /// Convert the optimizer options into it's raw representation
    fn to_raw(self) -> spv_optimizer_options {
        self.raw
    }
}

impl Drop for OptimizerOptions {
    fn drop(&mut self) {
        unsafe { spvOptimizerOptionsDestroy(self.raw); }
    }
}

impl Default for OptimizerOptions {
    fn default() -> Self {
        Self::new()
    }
}

/// An optimizer instance for spirv binaries
pub struct Optimizer {
    optimizer: spv_optimizer
}

impl Optimizer {
    /// Create a new optimizer instance for a given environment
    pub fn new(env: TargetEnv) -> Self {
        Self {
            optimizer: unsafe { spvOptimizerCreate(env.to_raw()) }
        }
    }

    // TODO: Message consumers

    /// Register several optimization passes from a set of flags.
    /// 
    /// This only succeeds if all flags are valid
    pub fn register_passes_from_flags<'a>(mut self, flags: &'a [&'a str]) -> Result<Self, OptimizerError> {
        for flag in flags {
            self = self.register_pass_from_flag(flag)?;
        }

        Ok(self)
    }

    /// Register an optimization pass from a given flag.
    /// This only accepts
    /// |flag| values of the form "--pass_name[=pass_args]".  If no such pass
    /// exists, it returns false.  Otherwise, the pass is registered and it returns
    /// true.
    ///
    /// The following flags have special meaning:
    ///
    /// -O: Registers all performance optimization passes
    ///     (Optimizer::RegisterPerformancePasses)
    ///
    /// -Os: Registers all size optimization passes
    ///      (Optimizer::RegisterSizePasses).
    ///
    /// --legalize-hlsl: Registers all passes that legalize SPIR-V generated by an
    ///                  HLSL front-end.
    pub fn register_pass_from_flag(self, flag: &str) -> Result<Self, OptimizerError> {
        unsafe {
            let c_flag = CString::new(flag)
                .expect("Invalid flag provided. Flags must be valid C strings");

            let result = spvOptimizerRegisterPassFromFlag(
                self.optimizer,
                c_flag.as_ptr()
            );

            if !result {
                Err(OptimizerError::InvalidFlag(flag.to_owned()))
            }
            else {
                Ok(self)
            }
        }
    }

    /// Check if a flag has a valid form for the optimizer.
    ///
    /// --pass_name[=pass_args]
    /// -O
    /// -Os
    ///
    /// If |flag| takes one of the forms above, it returns true.  Otherwise, it
    /// returns false.
    pub fn flag_has_valid_form(&self, flag: &str) -> bool {
        unsafe {
            let c_flag = CString::new(flag)
                .expect("Invalid flag provided. Flags must be valid C strings");
                
            spvOptimizerFlagHasValidForm(c_flag.as_ptr())
        }
    }

    /// Registers passes that attempt to improve performance of generated code.
    /// This sequence of passes is subject to constant review and will change
    /// from time to time.
    pub fn register_performance_passes(self) -> Self {
        unsafe { spvOptimizerRegisterPerformancePasses(self.optimizer); }
        self
    }

    /// Registers passes that attempt to improve the size of generated code.
    /// This sequence of passes is subject to constant review and will change
    /// from time to time.
    pub fn register_size_passes(self) -> Self {
        unsafe { spvOptimizerRegisterSizePasses(self.optimizer); }
        self
    }

    /// Registers passes that have been prescribed for converting from Vulkan to
    /// WebGPU. This sequence of passes is subject to constant review and will
    /// change from time to time.
    pub fn register_vulkan_to_web_gpu_passes(self) -> Self {
        unsafe { spvOptimizerRegisterVulkanToWebGPUPasses(self.optimizer); }
        self
    }

    /// Registers passes that have been prescribed for converting from WebGPU to
    /// Vulkan. This sequence of passes is subject to constant review and will
    /// change from time to time.
    pub fn register_web_gpu_to_vulkan_passes(self) -> Self {
        unsafe { spvOptimizerRegisterWebGPUToVulkanPasses(self.optimizer); }
        self
    }

    /// Registers passes that attempt to legalize the generated code.
    ///
    /// Note: this recipe is specially designed for legalizing SPIR-V. It should be
    /// used by compilers after translating HLSL source code literally. It should
    /// *not* be used by general workloads for performance or size improvement.
    ///
    /// This sequence of passes is subject to constant review and will change
    /// from time to time.
    pub fn register_legalization_passes(self) -> Self {
        unsafe { spvOptimizerRegisterLegalizationPasses(self.optimizer); }
        self
    }

    /// Change the target env from the one the optimizer was created with
    pub fn set_target_env(&mut self, env: TargetEnv) {
        unsafe { spvOptimizerSetTargetEnv(self.optimizer, env.to_raw()); }
    }

    /// Run the optimizer with it's current passes and default options on the provided binary
    pub fn run(&self, binary: &[u32]) -> Result<Vec<u32>, OptimizerError> {
        unsafe {
            let bin_ptr = binary.as_ptr();
            let bin_len = binary.len();

            let mut out_bin = ptr::null_mut();
            if spvOptimizerRun(self.optimizer, bin_ptr, bin_len, &mut out_bin) {
                let out_ptr = (*out_bin).code;
                let out_len = (*out_bin).word_count;
                let mut opt_bin = Vec::with_capacity(out_len);
                
                ptr::copy_nonoverlapping(out_ptr, opt_bin.as_mut_ptr(), out_len);

                opt_bin.set_len(out_len);

                spvBinaryDestroy(out_bin);

                Ok(opt_bin)
            }
            else {
                Err(OptimizerError::OptimizationFailed())
            }
        }
    }

    /// Run the optimizer with it's current passes and the provided options on the provided binary
    pub fn run_with_options(&self, binary: &[u32], options: OptimizerOptions) -> Result<Vec<u32>, OptimizerError> {
        unsafe {
            let bin_ptr = binary.as_ptr();
            let bin_len = binary.len();

            let mut out_bin = ptr::null_mut();
            if spvOptimizerRunWithOptions(self.optimizer, bin_ptr, bin_len, &mut out_bin, options.to_raw()) {
                let out_ptr = (*out_bin).code;
                let out_len = (*out_bin).word_count;
                let mut opt_bin = Vec::with_capacity(out_len);
                
                ptr::copy_nonoverlapping(out_ptr, opt_bin.as_mut_ptr(), out_len);

                opt_bin.set_len(out_len);

                spvBinaryDestroy(out_bin);

                Ok(opt_bin)
            }
            else {
                Err(OptimizerError::OptimizationFailed())
            }
        }
    }
}

impl Drop for Optimizer {
    fn drop(&mut self) {
        unsafe { spvOptimizerDestroy(self.optimizer); }
    }
}
