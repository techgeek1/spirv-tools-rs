//! Spirv Tools RS - A thin wrapper over the Spirv-Tools provided by Kronos

mod bindings;

use std::ffi::CString;
use std::ptr;
use std::slice;

use self::bindings::*;

// TODO: Convert the digagnostic into a useful error

pub type SpvResult<T> = Result<T, SpvError>;

pub enum SpvTargetEnv {
    /// SPIR-V 1.0 latest revision, no other restrictions
    Universal1_0,
    /// Vulkan 1.0 latest revision
    Vulkan1_0,
    /// SPIR-V 1.1 latest revision, no other restrictions
    Universal1_1,
    /// OpenCL Full Profile 2.1 latest revision
    OpenCL2_1,
    /// OpenCL Full Profile 2.2 latest revision
    OpenCL2_2,
    /// OpenGL 4.0 plus GL_ARB_gl_spirv, latest revisions
    OpenGL4_0,
    /// OpenGL 4.1 plus GL_ARB_gl_spirv, latest revisions
    OpenGL4_1,
    /// OpenGL 4.2 plus GL_ARB_gl_spirv, latest revisions
    OpenGL4_2,
    /// OpenGL 4.3 plus GL_ARB_gl_spirv, latest revisions
    OpenGL4_3,
    
    // There is no variant for OpenGL 4.4.

    /// OpenGL 4.5 plus GL_ARB_gl_spirv, latest revisions
    OpenGl4_5,
    /// SPIR-V 1.2, latest revision, no other restrictions
    Universal1_2,
    /// OpenCL Full Profile 1.2 plus cl_khr_il_program latest revision
    OpenCL1_2,
    /// OpenCL Embedded Profile 1.2 plus cl_khr_il_program, latest revision
    OpenCLEmbedded1_2,
    /// OpenCL Full Profile 2.0 plus cl_khr_il_program, latest revision
    OpenCL2_0,
    // OpenCL Embedded Profile 2.0 plus cl_khr_il_program, latest revision
    OpenCLEmbedded2_0,
    /// OpenCL Embedded Profile 2.1 latest revision
    OpenCLEmbedded2_1,
    /// OpenCL Embedded Profile 2.2 latest revision  
    OpenCLEmbedded2_2,
    /// SPIR-V 1.3 latest revision, no other restrictions
    Universal1_3,
    /// Vulkan 1.1 latest revision
    Vulkan1_1,
    /// Work in progress WebGPU 1.0
    WebGPU0,
}

impl SpvTargetEnv {
    /// Convert the rust version of `SpvTargetEnv` into the C version
    fn to_binding(self) -> spv_target_env {
        match self {
            SpvTargetEnv::Universal1_0          => spv_target_env::UNIVERSAL_1_0,
            SpvTargetEnv::Vulkan1_0             => spv_target_env::VULKAN_1_0,
            SpvTargetEnv::Universal1_1          => spv_target_env::UNIVERSAL_1_1,
            SpvTargetEnv::OpenCL2_1             => spv_target_env::OPENCL_2_1,
            SpvTargetEnv::OpenCL2_2             => spv_target_env::OPENCL_2_2,
            SpvTargetEnv::OpenGL4_0             => spv_target_env::OPENGL_4_0,
            SpvTargetEnv::OpenGL4_1             => spv_target_env::OPENGL_4_1,
            SpvTargetEnv::OpenGL4_2             => spv_target_env::OPENGL_4_2,
            SpvTargetEnv::OpenGL4_3             => spv_target_env::OPENGL_4_3,
            SpvTargetEnv::OpenGl4_5             => spv_target_env::OPENGL_4_5,
            SpvTargetEnv::Universal1_2          => spv_target_env::UNIVERSAL_1_2,
            SpvTargetEnv::OpenCL1_2             => spv_target_env::OPENCL_1_2,
            SpvTargetEnv::OpenCLEmbedded1_2     => spv_target_env::OPENCL_EMBEDDED_1_2,
            SpvTargetEnv::OpenCL2_0             => spv_target_env::OPENCL_2_0,
            SpvTargetEnv::OpenCLEmbedded2_0     => spv_target_env::OPENCL_EMBEDDED_2_0,
            SpvTargetEnv::OpenCLEmbedded2_1     => spv_target_env::OPENCL_EMBEDDED_2_1,
            SpvTargetEnv::OpenCLEmbedded2_2     => spv_target_env::OPENCL_EMBEDDED_2_2,
            SpvTargetEnv::Universal1_3          => spv_target_env::UNIVERSAL_1_3,
            SpvTargetEnv::Vulkan1_1             => spv_target_env::VULKAN_1_1,
            SpvTargetEnv::WebGPU0               => spv_target_env::WEBGPU_0
        }
    }
}

/// An error generated by spirv-tools
pub enum SpvError {
    Unsupported,
    EndOfStream,
    Warning,
    FailedMatch,
    RequestedTermination,
    Internal,
    OutOfMemory,
    InvalidPointer,
    InvalidBinary,
    InvalidText,
    InvalidTable,
    InvalidValue,
    InvalidDiagnostic,
    InvalidLookup,
    InvalidId,
    InvalidCfg,
    InvalidLayout,
    InvalidCapability,
    InvalidData,
    MissingExtension,
    WrongVersion,
}

impl SpvError {
    /// Convert an `spv_result_t` into an `SpvError`
    fn from_result(result: spv_result_t) -> Self {
        match result {
            spv_result_t::UNSUPPORTED               => SpvError::Unsupported,
            spv_result_t::END_OF_STREAM             => SpvError::EndOfStream,
            spv_result_t::WARNING                   => SpvError::Warning,
            spv_result_t::FAILED_MATCH              => SpvError::FailedMatch,
            spv_result_t::REQUESTED_TERMINATION     => SpvError::RequestedTermination,
            spv_result_t::ERROR_INTERNAL            => SpvError::Internal,
            spv_result_t::ERROR_OUT_OF_MEMORY       => SpvError::OutOfMemory,
            spv_result_t::ERROR_INVALID_POINTER     => SpvError::InvalidPointer,
            spv_result_t::ERROR_INVALID_BINARY      => SpvError::InvalidBinary,
            spv_result_t::ERROR_INVALID_TEXT        => SpvError::InvalidText,
            spv_result_t::ERROR_INVALID_TABLE       => SpvError::InvalidTable,
            spv_result_t::ERROR_INVALID_VALUE       => SpvError::InvalidValue,
            spv_result_t::ERROR_INVALID_DIAGNOSTIC  => SpvError::InvalidDiagnostic,
            spv_result_t::ERROR_INVALID_LOOKUP      => SpvError::InvalidLookup,
            spv_result_t::ERROR_INVALID_ID          => SpvError::InvalidId,
            spv_result_t::ERROR_INVALID_CFG         => SpvError::InvalidCfg,
            spv_result_t::ERROR_INVALID_LAYOUT      => SpvError::InvalidLayout,
            spv_result_t::ERROR_INVALID_CAPABILITY  => SpvError::InvalidCapability,
            spv_result_t::ERROR_INVALID_DATA        => SpvError::InvalidData,
            spv_result_t::ERROR_MISSING_EXTENSION   => SpvError::MissingExtension,
            spv_result_t::ERROR_WRONG_VERSION       => SpvError::WrongVersion,

            _                                       => panic!("Not an error!")
        }
    }
}

pub fn assemble(source: String, env: SpvTargetEnv) -> Result<Vec<u32>, SpvError> {
    unsafe {
        let context = spvContextCreate(env.to_binding());
        let src = CString::new(source)
            .expect("Failed to read source"); // TODO: Replace with a proper error

        let str_ptr = src.as_ptr();
        let str_len = src.as_bytes().len();
        let out_bin: spv_binary = ptr::null_mut();
        let out_diag: spv_diagnostic = ptr::null_mut(); // TODO: Read out diagnostic info

        let result = spvTextToBinary(
            context, 
            str_ptr,
            str_len,
            &mut out_bin as *mut spv_binary,
            &mut out_diag as *mut spv_diagnostic
        );

        assert!(!out_bin.is_null());

        let binary = {
            let slice = slice::from_raw_parts(
                (*out_bin).code, 
                (*out_bin).word_count as usize
            );

            let mut binary = Vec::with_capacity(slice.len());
            binary.copy_from_slice(slice);
            binary
        };

        match result {
            spv_result_t::SUCCESS => Ok(binary),
            _                     => Err(SpvError::from_result(result))
        }
    }
}

pub fn dissassemble(binary: Vec<u32>) -> Result<String, SpvDiagnostic> {
    unimplemented!()
}

pub fn validate(binary: &[u32]) -> Result<(), SpvDiagnostic> {
    unimplemented!()
}

pub fn optimize(binary: Vec<u32>) -> Result<Vec<u32>, SpvDiagnostic> {
    unimplemented!()
}